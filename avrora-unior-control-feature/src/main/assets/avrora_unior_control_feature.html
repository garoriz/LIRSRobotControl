<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avrora Unior</title>
    <script src="https://cdn.jsdelivr.net/npm/roslib/build/roslib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.8.0/dist/nipplejs.min.js"></script>
    <style>
        body {
          font-family: sans-serif;
          text-align: center;
          margin: 0;
          padding: 0;
          background-color: #f0f0f0;
        }

        h1 {
          margin: 20px;
          font-size: 24px;
        }

        #status {
          font-weight: bold;
          margin-top: 10px;
          font-size: 18px;
        }

        #connect-block {
          margin: 20px;
        }

        #ipInput {
          font-size: 20px;
          padding: 14px 12px;
          width: 250px;
          border: 1px solid #ccc;
          border-radius: 10px;
          margin-bottom: 12px;
        }

        #connect-block button {
          font-size: 20px;
          padding: 14px 24px;
          border: none;
          background-color: #007bff;
          color: white;
          border-radius: 10px;
          cursor: pointer;
        }

        #connect-block button:hover {
          background-color: #0056b3;
        }

        #stopBtn {
          top: 10px;
          right: 10px;
          font-size: 18px;
          background: red;
          color: white;
          padding: 10px 20px;
          border: none;
          border-radius: 10px;
          width: 100%;
          max-width: 420px;
          display: block;
          margin: 0 auto 20px auto;
        }

        #сanvas {
          width: 300px;
          height: 300px;
          background: #000;
          border-radius: 10px;
          margin-top: 20px;
        }

        #cameraStream {
          width: 100%;
          max-width: 640px;
          border-radius: 10px;
          margin-top: 20px;
          margin-bottom: 60px;
        }

        #joystick {
          width: 200px;
          height: 200px;
          background-color: #fff;
          border-radius: 16px;
          box-shadow: 0 0 8px rgba(0,0,0,0.1);
          margin: auto auto 20px auto;
          touch-action: none;
          position: relative;
        }

        #button-controls button {
          font-size: 20px;
          padding: 12px 20px;
          margin: 5px;
          border: none;
          border-radius: 10px;
          background-color: #444;
          color: white;
          cursor: pointer;
          min-width: 100px;
        }
        #button-controls button:hover {
          background-color: #000;
        }

        .control-grid {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 12px;
        }

        .control-grid .row {
          display: flex;
          gap: 12px;
        }

        .control-grid .row.center {
          justify-content: center;
        }

        .control-grid button {
          font-size: 20px;
          padding: 14px 20px;
          min-width: 110px;
          border: none;
          border-radius: 10px;
          background-color: #444;
          color: white;
          cursor: pointer;
          text-align: center;
        }

        .control-grid button:hover {
          background-color: #000;
        }

        #joystick-dual {
          display: flex;
          justify-content: space-between;
          width: 100%;
          padding: 0 10 px;
          box-sizing: border-box;
        }

        .joystick-wrapper {
          display: flex;
          flex-direction: column;
          align-items: center;
          margin-bottom: 20px;
        }

        #joystick-move, #joystick-turn {
          width: 40vw;
          max-width: 300px;
          height: 40vw;
          max-height: 300px;
          background-color: #fff;
          border-radius: 16px;
          box-shadow: 0 0 8px rgba(0,0,0,0.1);
          position: relative;
          touch-action: none;
          margin: 5px;
        }

        .joystick-label {
          margin-top: 8px;
          font-size: 16px;
          font-weight: bold;
          color: #333;
          text-align: center;
        }
    </style>
</head>
<body>

<h1>Control of Avrora Unior</h1>

<div id="connect-block">
    <input type="text" id="ipInput" placeholder="Machine IP" required oninput="filterIP(this)"
           maxlength="15" inputmode="decimal">
    <br>
    <button onclick="connect()">Connect</button>
    <div id="status">Disconnected</div>
</div>

<div style="margin: 16px;">
    <label for="modeSelect"><b>Control mode:</b></label>
    <select id="modeSelect" onchange="changeMode()" style="font-size: 18px; padding: 6px;">
        <option value="joystick">Joystick</option>
        <option value="buttons">Buttons</option>
        <option value="dual">Two joysticks</option>
    </select>
</div>

<div id="mode-environment" style="margin: 16px;">
    <label for="modeEnvironment"><b>Environment mode:</b></label>
    <select id="modeEnvironment" onchange="changeModeEnvironment()" style="font-size: 18px; padding: 6px;">
        <option value="lidar">Camera</option>
        <option value="map">Map</option>
    </select>
</div>

<button id="stopBtn">⏹ Стоп</button>

<img id="cameraStream" alt="Camera video"/>

<canvas id="сanvas" width="300" height="300"
        style="background: #000; border-radius: 10px; margin-top: 20px; display: none;"></canvas>

<div id="joystick-container">
    <div class="joystick-wrapper">
        <div id="joystick"></div>
        <div>Control</div>
    </div>
</div>

<div id="button-controls" style="display: none; margin-top: 20px;">
    <div class="control-grid">
        <div class="row center">
            <button onclick="drive('forward')">⬆ Forward</button>
        </div>
        <div class="row">
            <button onclick="drive('left')">⬅ To the left</button>
            <button onclick="drive('stop')">⏹ Stop</button>
            <button onclick="drive('right')">➡ To the right</button>
        </div>
        <div class="row center">
            <button onclick="drive('backward')">⬇ Back</button>
        </div>
    </div>
</div>

<div id="joystick-dual" style="display: none;">
    <div class="joystick-wrapper">
        <div id="joystick-move"></div>
        <div>Speed</div>
    </div>
    <div class="joystick-wrapper">
        <div id="joystick-turn"></div>
        <div>Turning</div>
    </div>
</div>

<script>
    let ros = null;
    let publisher = null;

    let steering = 0.0;
    let speed = 0.0;

    let mapSub = null;
    let robotPose = null;
    const canvas = document.getElementById('сanvas');
    const ctx = canvas.getContext('2d');
    let scale = 1.0;
    let targetScale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    let lastTouch = null;
    let lastDist = null;
    let mapData = null;
    let goalActionClient = null;
    let amclSub = null;
    let goalQueue = [];
    let isSendingGoal = false;
    let topicsClient = null;

    let globalPlan = [];

    canvas.addEventListener("touchstart", (e) => {
        if (e.touches.length === 1) {
            lastTouch = e.touches[0];
        } else if (e.touches.length === 2) {
            lastDist = getDistance(e.touches);
        }
    });

    function getDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();

        if (e.touches.length === 1 && lastTouch) {
            const dx = e.touches[0].clientX - lastTouch.clientX;
            const dy = e.touches[0].clientY - lastTouch.clientY;
            offsetX += dx;
            offsetY += dy;
            lastTouch = e.touches[0];
        }

        if (e.touches.length === 2 && lastDist !== null) {
            const newDist = getDistance(e.touches);
            const zoomFactor = newDist / lastDist;

            applyZoomToCanvasCenter(zoomFactor);
            lastDist = newDist;
        }
    });

    function applyZoomToCanvasCenter(zoomFactor) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        const worldX = (centerX - offsetX) / scale;
        const worldY = (centerY - offsetY) / scale;

        targetScale *= zoomFactor;
        scale = targetScale;

        offsetX = centerX - worldX * scale;
        offsetY = centerY - worldY * scale;
    }

    canvas.addEventListener("touchend", () => {
        lastTouch = null;
        lastDist = null;
    });

    canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        const resolution = mapData.info.resolution;
        const origin = mapData.info.origin;

        const clickedGoalIndex = goalQueue.findIndex((goal) => {
            const mapX = (goal.x - origin.position.x) / resolution;
            const mapY = mapData.info.height - (goal.y - origin.position.y) / resolution;

            const canvasX = mapX * scale + offsetX;
            const canvasY = mapY * scale + offsetY;

            const dx = clickX - canvasX;
            const dy = clickY - canvasY;

            return Math.sqrt(dx * dx + dy * dy) < 10;
        });

        if (clickedGoalIndex !== -1 && goalQueue[clickedGoalIndex].status === 'sent') {
            goalActionClient.cancel();
            globalPlan = [];
            return;
        } else if (clickedGoalIndex !== -1) {
            const removed = goalQueue.splice(clickedGoalIndex, 1)[0];
            return;
        }

        const mapX = (clickX - offsetX) / scale;
        const mapY = (clickY - offsetY) / scale;
        const invY = mapData.info.height - mapY;

        const goalWorldX = mapX * resolution + origin.position.x;
        const goalWorldY = invY * resolution + origin.position.y;

        goalQueue.push({
          x: goalWorldX,
          y: goalWorldY,
          status: 'pending'
        });

        if (!isSendingGoal) {
          sendNextGoal();
        }
    });

    function sendNextGoal() {
      if (goalQueue.length === 0) {
        isSendingGoal = false;
        return;
      }

      isSendingGoal = true;

      const currentGoal = goalQueue[0];

      let rosGoal = new ROSLIB.Goal({
            actionClient: goalActionClient,
            goalMessage: {
                target_pose: {
                    header: {
                        frame_id: 'map'
                    },
                    pose: {
                        position: { x: currentGoal.x, y: currentGoal.y, z: 0 },
                        orientation: { x: 0, y: 0, z: 0, w: 1 }
                    }
                }
            }
      });

      rosGoal.on('result', function(result) {
          rosGoal = null;
          goalQueue.shift();
          sendNextGoal();
      });

      rosGoal.send();
      currentGoal.status = 'sent';
    }

    canvas.addEventListener("wheel", (e) => {
        e.preventDefault();

        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

        const rect = canvas.getBoundingClientRect();
        const centerX = e.clientX - rect.left;
        const centerY = e.clientY - rect.top;

        // точка зума в координатах мира
        const worldX = (centerX - offsetX) / scale;
        const worldY = (centerY - offsetY) / scale;

        // применяем масштаб
        targetScale *= zoomFactor;
        scale = targetScale;

        // пересчитываем смещения — зум вокруг курсора
        offsetX = centerX - worldX * scale;
        offsetY = centerY - worldY * scale;
    });

    function filterIP(input) {
      input.value = input.value.replace(/[^0-9.]/g, '');
    }

    function connect() {
      const ip = document.getElementById("ipInput").value.trim();
      if (!ip) return alert("Enter the IP of the ROS machine");

      ros = new ROSLIB.Ros({ url: `ws://${ip}:9090` });

      ros.on('connection', () => {
        document.getElementById('status').textContent = 'Connected';
        document.getElementById('status').style.color = 'green';

        publisher = new ROSLIB.Topic({
          ros: ros,
          name: '/junior_car/ackermann_cmd',
          messageType: 'ackermann_msgs/msg/AckermannDriveStamped'
        });

        subscribeToCompressedImage();
      });

      ros.on('error', err => {
        document.getElementById('status').textContent = 'Connection error';
        document.getElementById('status').style.color = 'red';
        console.error(err);
      });

      ros.on('close', () => {
        document.getElementById('status').textContent = 'Disconnected';
        document.getElementById('status').style.color = 'gray';
      });
    }

    const joystick = nipplejs.create({
      zone: document.getElementById('joystick'),
      mode: 'dynamic',
      position: { left: '50%'},
      color: 'blue',
      size: 200
    });

    joystick.on('move', (evt, data) => {
      if (!publisher || !ros || !ros.isConnected) return;
      if (!data.angle || typeof data.angle.radian !== 'number') return;

      const angle = data.angle.radian;
      const distance = data.distance || 0;

      speed = Math.sin(angle) * distance * 0.04;
      steering = -Math.cos(angle) * distance * 0.01;

      sendDriveCommand();
    });

    joystick.on('end', () => {
      speed = 0.0;
      steering = 0.0;
      sendDriveCommand();
    });

    function sendDriveCommand() {
      if (!publisher || !ros || !ros.isConnected) return;

      const now = Date.now();
      const sec = Math.floor(now / 1000);
      const nanosec = (now % 1000) * 1e6;

      const msg = new ROSLIB.Message({
        header: {
          stamp: { sec: sec, nanosec: nanosec },
          frame_id: "base_link"
        },
        drive: {
          steering_angle: steering,
          speed: speed
        }
      });

      publisher.publish(msg);
    }

    let driveTimer = null;

    function drive(direction) {
      clearInterval(driveTimer);

      switch (direction) {
        case 'forward':
          speed = 3.5;
          steering = 0.0;
          break;
        case 'backward':
          speed = -3.5;
          steering = 0.0;
          break;
        case 'left':
          speed = 1.3;
          steering = 0.4;
          break;
        case 'right':
          speed = 1.3;
          steering = -0.4;
          break;
        case 'stop':
        default:
          speed = 0.0;
          steering = 0.0;
          sendDriveCommand();
          return;
      }

      sendDriveCommand();
      driveTimer = setInterval(sendDriveCommand, 150);
    }


    function changeMode() {
      const mode = document.getElementById('modeSelect').value;
      document.getElementById('joystick-container').style.display = (mode === 'joystick') ? 'block' : 'none';
      document.getElementById('button-controls').style.display = (mode === 'buttons') ? 'block' : 'none';
      document.getElementById('joystick-dual').style.display = (mode === 'dual') ? 'flex' : 'none';

      if (mode === 'dual') initDualJoysticks();
    }

    let dualMoveJoystick = null;
    let dualTurnJoystick = null;

    function initDualJoysticks() {
      if (dualMoveJoystick) dualMoveJoystick.destroy();
      if (dualTurnJoystick) dualTurnJoystick.destroy();

      dualMoveJoystick = nipplejs.create({
        zone: document.getElementById('joystick-move'),
        mode: 'dynamic',
        position: { left: '50%', top: '50%' },
        color: 'blue',
        size: 125
      });

      dualTurnJoystick = nipplejs.create({
        zone: document.getElementById('joystick-turn'),
        mode: 'dynamic',
        position: { left: '50%', top: '50%' },
        color: 'green',
        size: 125
      });

      dualMoveJoystick.on('move', (evt, data) => {
        const angle = data?.angle?.radian;
        const dist = data?.distance || 0;
        if (angle != null) {
            speed = Math.sin(angle) * dist * 0.04;

            sendDriveCommand();
        }
      });

      dualMoveJoystick.on('end', () => {
        speed = 0.0;
        sendDriveCommand();
      });

      dualTurnJoystick.on('move', (evt, data) => {
        const angle = data?.angle?.radian;
        const dist = data?.distance || 0;
        if (angle != null) {
            steering = -Math.cos(angle) * dist * 0.02;

            sendDriveCommand();
        }
      });

      dualTurnJoystick.on('end', () => {
        steering = 0.0;
        sendDriveCommand();
      });
    }

    function subscribeToCompressedImage() {
      const imgTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/camera/depth/image_raw/compressed',
        messageType: 'sensor_msgs/CompressedImage'
      });

      imgTopic.subscribe((msg) => {
        const format = msg.format.toLowerCase();
        const imgElement = document.getElementById('cameraStream');

        imgElement.src = `data:image/${format};base64,${msg.data}`;
      });
    }
</script>

</body>
</html>
