<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ArtBul</title>
    <script src="https://cdn.jsdelivr.net/npm/roslib/build/roslib.min.js"></script>
    <style>
        html, body {
          margin: 0;
          padding: 0;
          height: 100%;
          overflow: hidden;
          background: #111;
        }
        canvas {
          display: block;
          background: #000;
          border-radius: 10px;
        }

        #modeEnvironment {
          max-width: 420px;
          width: 50%;
          text-align: center;
          display: block;
          font-size: 24px;
          margin: 8px auto;
        }

        #stopBtn {
          display: block;
          top: 10px;
          right: 10px;
          font-size: 18px;
          background: red;
          color: white;
          padding: 10px 20px;
          border: none;
          border-radius: 10px;
          width: 50%;
          max-width: 420px;
          margin: 0 auto;
          margin-bottom: 8px;
        }

        #saveMapBtn {
          display: block;
          top: 10px;
          right: 10px;
          font-size: 18px;
          background: blue;
          color: white;
          padding: 10px 20px;
          border: none;
          border-radius: 10px;
          width: 50%;
          max-width: 420px;
          margin: 0 auto;
          margin-bottom: 8px;
        }

        #cameraStream {
          width: 100%;
          max-width: 640px;
          border-radius: 10px;
          margin-top: 20px;
          margin-bottom: 60px;
          display: none;
        }
    </style>
</head>
<body>

<select id="modeEnvironment" onchange="changeModeEnvironment()">
    <option value="map">Map</option>
    <option value="lidar">Lidar</option>
    <option value="camera">Camera</option>
</select>

<button id="stopBtn">⏹ Стоп</button>

<button id="saveMapBtn">Сохранить карту</button>

<canvas id="canvas"
        style="background: #000;"></canvas>

<img id="cameraStream" alt="Camera video"/>

<script>
    const params = new URLSearchParams(window.location.search);
    const host = params.get("host");
    let ros = new ROSLIB.Ros({ url: `ws://${host}:9090` });
    let cmdVelPub = null;

    let lidarSub = null;
    let mapSub = null;
    let robotPose = null;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let scale = 1.0;
    let targetScale = 1.0;
    let offsetX = 0;
    let offsetY = 0;
    let lastTouch = null;
    let lastDist = null;
    let mapData = null;
    let goalActionClient = null;
    let amclSub = null;
    let goalQueue = [];
    let isSendingGoal = false;
    let topicsClient = null;
    let animationId = 0;
    let imgTopic = null;

    let globalPlan = [];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    resizeCanvas();

    window.addEventListener("resize", resizeCanvas);

    ros.on('connection', () => {
        setupPublisher();
        subscribeToMap();
    });

    function setupPublisher() {
      cmdVelPub = new ROSLIB.Topic({
        ros: ros,
        name: '/mobile_base_controller/cmd_vel',
        messageType: 'geometry_msgs/msg/TwistStamped'
      });
    }

    canvas.addEventListener("touchstart", (e) => {
        if (e.touches.length === 1) {
            lastTouch = e.touches[0];
        } else if (e.touches.length === 2) {
            lastDist = getDistance(e.touches);
        }
    });

    function getDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();

        if (e.touches.length === 1 && lastTouch) {
            const dx = e.touches[0].clientX - lastTouch.clientX;
            const dy = e.touches[0].clientY - lastTouch.clientY;
            offsetX += dx;
            offsetY += dy;
            lastTouch = e.touches[0];
        }

        if (e.touches.length === 2 && lastDist !== null) {
            const newDist = getDistance(e.touches);
            const zoomFactor = newDist / lastDist;

            applyZoomToCanvasCenter(zoomFactor);
            lastDist = newDist;
        }
    });

    function applyZoomToCanvasCenter(zoomFactor) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        const worldX = (centerX - offsetX) / scale;
        const worldY = (centerY - offsetY) / scale;

        targetScale *= zoomFactor;
        scale = targetScale;

        offsetX = centerX - worldX * scale;
        offsetY = centerY - worldY * scale;
    }

    canvas.addEventListener("touchend", () => {
        lastTouch = null;
        lastDist = null;
    });

    canvas.addEventListener("click", (e) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        const resolution = mapData.info.resolution;
        const origin = mapData.info.origin;

        const clickedGoalIndex = goalQueue.findIndex((goal) => {
            const mapX = (goal.x - origin.position.x) / resolution;
            const mapY = mapData.info.height - (goal.y - origin.position.y) / resolution;

            const canvasX = mapX * scale + offsetX;
            const canvasY = mapY * scale + offsetY;

            const dx = clickX - canvasX;
            const dy = clickY - canvasY;

            return Math.sqrt(dx * dx + dy * dy) < 10;
        });

        if (clickedGoalIndex !== -1 && goalQueue[clickedGoalIndex].status === 'sent') {
            goalActionClient.cancel();
            globalPlan = [];
            return;
        } else if (clickedGoalIndex !== -1) {
            const removed = goalQueue.splice(clickedGoalIndex, 1)[0];
            return;
        }

        const mapX = (clickX - offsetX) / scale;
        const mapY = (clickY - offsetY) / scale;
        const invY = mapData.info.height - mapY;

        const goalWorldX = mapX * resolution + origin.position.x;
        const goalWorldY = invY * resolution + origin.position.y;

        goalQueue.push({
          x: goalWorldX,
          y: goalWorldY,
          status: 'pending'
        });

        if (!isSendingGoal) {
          sendNextGoal();
        }
    });

    function sendNextGoal() {
      if (goalQueue.length === 0) {
        isSendingGoal = false;
        return;
      }

      isSendingGoal = true;

      const currentGoal = goalQueue[0];

      let rosGoal = new ROSLIB.Goal({
            actionClient: goalActionClient,
            goalMessage: {
                target_pose: {
                    header: {
                        frame_id: 'map'
                    },
                    pose: {
                        position: { x: currentGoal.x, y: currentGoal.y, z: 0 },
                        orientation: { x: 0, y: 0, z: 0, w: 1 }
                    }
                }
            }
      });

      rosGoal.on('result', function(result) {
          rosGoal = null;
          goalQueue.shift();
          sendNextGoal();
      });

      rosGoal.send();
      currentGoal.status = 'sent';
    }

    canvas.addEventListener("wheel", (e) => {
        e.preventDefault();

        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;

        const rect = canvas.getBoundingClientRect();
        const centerX = e.clientX - rect.left;
        const centerY = e.clientY - rect.top;

        // точка зума в координатах мира
        const worldX = (centerX - offsetX) / scale;
        const worldY = (centerY - offsetY) / scale;

        // применяем масштаб
        targetScale *= zoomFactor;
        scale = targetScale;

        // пересчитываем смещения — зум вокруг курсора
        offsetX = centerX - worldX * scale;
        offsetY = centerY - worldY * scale;
    });

    function changeModeEnvironment() {
      const mode = document.getElementById('modeEnvironment').value;
      if (mode === 'map') {
        unsubscribeFromLidar();
        unsubscribeFromCompressedImage();
        subscribeToMap();
      } else if (mode === 'lidar') {
        unsubscribeFromMap();
        unsubscribeFromCompressedImage();
        subscribeToLidar();
      } else {
        unsubscribeFromMap();
        unsubscribeFromLidar();
        subscribeToCompressedImage();
      }
    }

    function subscribeToLidar() {
      lidarSub = new ROSLIB.Topic({
        ros: ros,
        name: '/scan',
        messageType: 'sensor_msgs/LaserScan'
      });

      lidarSub.subscribe(drawLidar);

      document.getElementById('canvas').style.display = 'block';
      document.getElementById('saveMapBtn').style.display = 'none';
      document.getElementById('cameraStream').style.display = 'none';
    }

    function drawLidar(scan) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      const robotRadius = 8;

      ctx.beginPath();
      ctx.arc(cx, cy, robotRadius, 0, 2 * Math.PI);
      ctx.fillStyle = '#007bff';
      ctx.fill();
      ctx.closePath();

      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx, cy - 20);
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.closePath();

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);

      const lidarScale = 100;

      for (let i = 0; i < scan.ranges.length; i++) {
        const angle = scan.angle_min + i * scan.angle_increment;
        const r = scan.ranges[i];

        if (r < scan.range_min || r > scan.range_max || !isFinite(r)) continue;

        const x = r * Math.cos(angle + Math.PI / 2) * lidarScale;
        const y = r * Math.sin(angle + Math.PI / 2) * lidarScale;

        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(x, -y, 2, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.restore();
    }

    function subscribeToMap() {
      mapSub = new ROSLIB.Topic({
        ros: ros,
        name: '/map',
        messageType: 'nav_msgs/OccupancyGrid'
      });

      mapSub.subscribe((msg) => {
        mapData = msg;
        drawMap(msg);
      });

      amclSub = new ROSLIB.Topic({
          ros: ros,
          name: '/amcl_pose',
          messageType: 'geometry_msgs/PoseWithCovarianceStamped'
      });

      amclSub.subscribe((msg) => {
          const pos = msg.pose.pose.position;
          const ori = msg.pose.pose.orientation;

          robotPose = {
              x: pos.x,
              y: pos.y,
              theta: 2 * Math.atan2(ori.z, ori.w)
          };
      });

      goalActionClient = new ROSLIB.ActionClient({
          ros: ros,
          serverName: '/move_base',
          actionName: 'move_base_msgs/MoveBaseAction'
      });

      topicsClient = new ROSLIB.Service({
          ros: ros,
          name: '/rosapi/topics',
          serviceType: 'rosapi/Topics'
      });

      topicsClient.callService(new ROSLIB.ServiceRequest({}), function (result) {
          const pathTopics = result.topics.filter(topic =>
              topic.match(/^\/move_base\/.*\/plan$/)
          );

          if (pathTopics.length > 0) {
              const selectedPathTopic = pathTopics[0];
              subscribeToPath(selectedPathTopic);
          }
      });

      document.getElementById('canvas').style.display = 'block';
      document.getElementById('saveMapBtn').style.display = 'block';
      document.getElementById('cameraStream').style.display = 'none';
    }

    function drawMap(map) {
        if (!map) return;
        mapData = map;

        const { width, height, resolution } = map.info;
        const data = map.data;

        scale += (targetScale - scale) * 0.1;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const cellSize = scale;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = x + (height - y - 1) * width;
                const val = data[i];
                if (val < 0) continue;

                const color = val === 100 ? '#000000' : '#ffffff';
                ctx.fillStyle = color;

                const drawX = offsetX + x * cellSize;
                const drawY = offsetY + y * cellSize;

                ctx.fillRect(drawX, drawY, cellSize, cellSize);
            }
        }

        drawGoals(ctx);

        if (robotPose) {
            const resolution = mapData.info.resolution;
            const origin = mapData.info.origin;

            const mapX = (robotPose.x - origin.position.x) / resolution;
            const mapY = mapData.info.height - (robotPose.y - origin.position.y) / resolution;

            const rX = mapX * scale + offsetX;
            const rY = mapY * scale + offsetY;

            const radius = 5;
            ctx.fillStyle = '#008000 ';
            ctx.beginPath();
            ctx.arc(rX, rY, radius, 0, 2 * Math.PI);
            ctx.fill();

            const dirLen = 20;
            ctx.strokeStyle = '#008000 ';
            ctx.beginPath();
            ctx.moveTo(rX, rY);
            ctx.lineTo(
                rX + dirLen * Math.cos(-robotPose.theta),
                rY + dirLen * Math.sin(-robotPose.theta)
            );
            ctx.stroke();
        }

        drawGlobalPath(ctx);

        animationId = requestAnimationFrame(() => drawMap(mapData));
    }

    function drawGlobalPath(ctx) {
        if (!mapData || globalPlan.length < 2) return;

        const resolution = mapData.info.resolution;
        const origin = mapData.info.origin;

        ctx.strokeStyle = '#0000ff';
        ctx.lineWidth = 2;
        ctx.beginPath();

        globalPlan.forEach((point, i) => {
            const mapX = (point.x - origin.position.x) / resolution;
            const mapY = mapData.info.height - (point.y - origin.position.y) / resolution;

            const canvasX = mapX * scale + offsetX;
            const canvasY = mapY * scale + offsetY;

            if (i === 0) {
                ctx.moveTo(canvasX, canvasY);
            } else {
                ctx.lineTo(canvasX, canvasY);
            }
        });

        ctx.stroke();
    }

    function subscribeToPath(topicName) {
      const pathSub = new ROSLIB.Topic({
        ros: ros,
        name: topicName,
        messageType: 'nav_msgs/Path'
      });

      pathSub.subscribe((msg) => {
        globalPlan = msg.poses.map(p => ({
          x: p.pose.position.x,
          y: p.pose.position.y
        }));
      });
    }

    document.getElementById("saveMapBtn").addEventListener("click", saveCanvasAsImage);

    function saveCanvasAsImage() {
        const link = document.createElement('a');
        link.download = 'map.png';
        link.href = canvas.toDataURL("image/png");
        link.click();
    }

    function unsubscribeFromLidar() {
      if (lidarSub != null) {
        lidarSub.unsubscribe();
      }
      lidarSub = null;
    }

    function unsubscribeFromMap() {
      if (mapSub != null) {
        mapSub.unsubscribe();
      }
      if (amclSub != null) {
        amclSub.unsubscribe();
      }
      mapSub = null;
      goalActionClient = null;
      amclSub = null;
      topicsClient = null;
      cancelAnimationFrame(animationId);
    }

    function drawGoals(ctx) {
      if (!mapData || goalQueue.length === 0) return;

      const resolution = mapData.info.resolution;
      const origin = mapData.info.origin;

      goalQueue.forEach(goal => {
        const mapX = (goal.x - origin.position.x) / resolution;
        const mapY = mapData.info.height - (goal.y - origin.position.y) / resolution;

        const canvasX = mapX * scale + offsetX;
        const canvasY = mapY * scale + offsetY;

        ctx.beginPath();
        ctx.arc(canvasX, canvasY, 8, 0, 2 * Math.PI);
        ctx.fillStyle = goal.status === 'sent' ? '#ffa500' : '#00cc00';
        ctx.fill();
        ctx.strokeStyle = '#003300';
        ctx.stroke();
      });
    }

    function subscribeToCompressedImage() {
      imgTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/camera/depth/image_raw/compressed',
        messageType: 'sensor_msgs/CompressedImage'
      });

      imgTopic.subscribe((msg) => {
        const format = msg.format.toLowerCase();
        const imgElement = document.getElementById('cameraStream');

        imgElement.src = `data:image/${format};base64,${msg.data}`;
      });

      document.getElementById('canvas').style.display = 'none';
      document.getElementById('saveMapBtn').style.display = 'none';
      document.getElementById('cameraStream').style.display = 'block';
    }

    function unsubscribeFromCompressedImage() {
      if (imgTopic != null) {
        imgTopic.unsubscribe();
      }

      imgTopic = null;
    }

    document.getElementById('stopBtn').addEventListener('click', stopRobot);

    function stopRobot() {
      goalActionClient.cancel();

      goalQueue = [];
      globalPlan = [];
      isSendingGoal = false;

      const now = Date.now();
      const sec = Math.floor(now / 1000);
      const nanosec = (now % 1000) * 1e6;

      const msg = new ROSLIB.Message({
        header: {
          stamp: { sec: sec, nanosec: nanosec },
          frame_id: 'base_link'
        },
        twist: {
          linear: { x: 0.0, y: 0.0 || 0.0, z: 0.0 },
          angular: { x: 0.0, y: 0.0, z: 0.0 }
        }
      });

      cmdVelPub.publish(msg);
    }
</script>
</body>
</html>
